
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>High-order functions. &#8212; dotty-cps-async 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/s4defs-roles.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Non-local returns" href="ReturningClause.html" />
    <link rel="prev" title="Dependency" href="BasicUsage.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ReturningClause.html" title="Non-local returns"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="BasicUsage.html" title="Dependency"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">dotty-cps-async 1.0.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">High-order functions.</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="high-order-functions">
<h1>High-order functions.<a class="headerlink" href="#high-order-functions" title="Permalink to this heading">¶</a></h1>
<p><a class="reference external" href="https://github.com/rssh/dotty-cps-async#dotty-cps-async"><strong>dotty-cps-async</strong></a> supports the automatic transformation of high-order functions, where the lambda expression argument contains <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/Async.scala#L19"><code class="docutils literal notranslate"><span class="pre">await</span></code></a>.</p>
<p>For example, assume an HTTP client providing the following interface to fetch some data from a list of remote servers.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="nc">HttpClient</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">fetchData</span><span class="p">(</span><span class="n">url</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">):</span><span class="w"> </span><span class="nc">Future</span><span class="p">[</span><span class="nc">String</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Then, we can fetch data from all servers just by using <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/Async.scala#L19"><code class="docutils literal notranslate"><span class="pre">await</span></code></a> in the <a class="reference external" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#map[B](f:A=%3EB):List[B]"><code class="docutils literal notranslate"><span class="pre">map</span></code></a> argument:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">urls</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">await</span><span class="p">(</span><span class="n">httpClient</span><span class="p">.</span><span class="n">fetchData</span><span class="p">(</span><span class="n">_</span><span class="p">))</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>Note that the default <a class="reference external" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#map[B](f:A=%3EB):List[B]"><code class="docutils literal notranslate"><span class="pre">map</span></code></a> method will run all operations sequentially. Sequential evaluation is needed to allow the code to work correctly for a case of updating the multidimensional array in a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop with asynchronous operations.</p>
<p>If we want all requests to run in parallel, we can start them in one map and, when all started - wait for the end of requests:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="n">urls</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="n">httpClient</span><span class="p">.</span><span class="n">fetchData</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="n">await</span><span class="p">(</span><span class="n">_</span><span class="p">))</span><span class="w"></span>
</pre></div>
</div>
<p>For handling awaits inside high-order functions, dotty-cps-async uses different strategies in dependency of execution runtime capabilities.</p>
<section id="async-shift-substitution">
<h2>Async shift substitution.<a class="headerlink" href="#async-shift-substitution" title="Permalink to this heading">¶</a></h2>
<p>The most general way is compile-time substitution: during async transform, <a class="reference external" href="https://github.com/rssh/dotty-cps-async#dotty-cps-async"><strong>dotty-cps-async</strong></a> substitutes method <a class="reference external" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#map[B](f:A=%3EB):List[B]"><code class="docutils literal notranslate"><span class="pre">map</span></code></a> with signature <code class="docutils literal notranslate"><span class="pre">List[A].map[B](f:</span> <span class="pre">A</span> <span class="pre">=&gt;</span> <span class="pre">B)</span></code> to</p>
<div class="highlight-scala notranslate" id="index-0"><div class="highlight"><pre><span></span><span class="n">summon</span><span class="p">[</span><span class="nc">AsyncShift</span><span class="p">[</span><span class="nc">List</span><span class="p">[</span><span class="nc">A</span><span class="p">]]].</span><span class="n">map</span><span class="p">[</span><span class="nc">F</span><span class="p">[</span><span class="n">_</span><span class="p">],</span><span class="w"> </span><span class="nc">B</span><span class="p">](</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">summon</span><span class="p">[</span><span class="nc">CpsMonad</span><span class="p">[</span><span class="nc">F</span><span class="p">]])</span><span class="w"></span>
</pre></div>
</div>
<p>which is implemented in the cps runtime with the signature</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="nc">AsyncShift</span><span class="p">[</span><span class="nc">List</span><span class="p">[</span><span class="nc">A</span><span class="p">]].</span><span class="n">map</span><span class="p">[</span><span class="nc">F</span><span class="p">[</span><span class="n">_</span><span class="p">],</span><span class="w"> </span><span class="nc">B</span><span class="p">](</span><span class="n">obj</span><span class="p">:</span><span class="w"> </span><span class="nc">List</span><span class="p">[</span><span class="nc">A</span><span class="p">],</span><span class="w"> </span><span class="n">cpsMonad</span><span class="p">:</span><span class="w"> </span><span class="nc">CpsMonad</span><span class="p">[</span><span class="nc">F</span><span class="p">])(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">B</span><span class="p">])</span><span class="w"></span>
</pre></div>
</div>
<p><a class="reference external" href="https://github.com/rssh/dotty-cps-async#dotty-cps-async"><strong>dotty-cps-async</strong></a> includes implementations of shifted methods for most objects of the <a class="reference external" href="https://www.scala-lang.org/api/current/"><strong>Scala standard library</strong></a>.</p>
<p>So, we can write something like</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="kd">val</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="n">getOrElse</span><span class="p">(</span><span class="w"> </span><span class="n">await</span><span class="p">(</span><span class="n">fetchData</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="loom-based-runtime-await">
<h2>Loom-based runtime await.<a class="headerlink" href="#loom-based-runtime-await" title="Permalink to this heading">¶</a></h2>
<p>JDK-21 includes a set of interfaces (project Loom) that allows execution of code in virtual threads,
where runtime blocking wait is not blocking from OS view:  real thread can execute tasks from other virtual threads during the wait.
In this case, we don’t need to substitute a high-order function but change instead the function argument to the original form.
Target monad should implement one of the
<cite>CpsRuntimeAwait</cite>  or
<cite>CpsRuntimeAwaitProvider</cite> typeclasses
(see
<a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/CpsRuntimeAwait.scala">sources</a>  )</p>
<p>For enabling this future, add <cite>dotty-cps-async-loom</cite> artifact to the dependencies of your project.</p>
</section>
<section id="how-to-provide-shifted-functions">
<h2>How to provide shifted functions.<a class="headerlink" href="#how-to-provide-shifted-functions" title="Permalink to this heading">¶</a></h2>
<section id="functional-interface">
<h3>Functional interface.<a class="headerlink" href="#functional-interface" title="Permalink to this heading">¶</a></h3>
<p>Suppose you want to make high-order methods of your class <code class="docutils literal notranslate"><span class="pre">C</span></code> be able to accept lambda functions with <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/Async.scala#L19"><code class="docutils literal notranslate"><span class="pre">await</span></code></a>.
For that purpose, you have to implement the <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/AsyncShift.scala#L11"><code class="docutils literal notranslate"><span class="pre">given</span> <span class="pre">AsyncShift[C]</span></code></a> type class with a shifted version of your high-order methods.
Such a ‘shifted’ version has an additional type parameter <code class="docutils literal notranslate"><span class="pre">F[_]</span></code> and an additional list of arguments, inserted first, containing the original object instance and an appropriate <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/CpsMonad.scala#L20"><code class="docutils literal notranslate"><span class="pre">CpsMonad[F]</span></code></a> instance.</p>
<p>Parameters should be changed in the following way:</p>
<ul class="simple">
<li><p>If the original parameter has type  <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=&gt;</span> <span class="pre">B</span></code>, then changed: <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=&gt;</span> <span class="pre">F[B]</span></code></p></li>
<li><p>If the original parameter is called by name with type <code class="docutils literal notranslate"><span class="pre">=&gt;</span> <span class="pre">A</span></code>, then changed: <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">F[A]</span></code></p></li>
<li><p>Otherwise, the changed parameter has the same type as the original.</p></li>
</ul>
<p>Example:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TaggedValue</span><span class="p">[</span><span class="nc">T</span><span class="p">](</span><span class="n">tag</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">[</span><span class="nc">S</span><span class="p">](</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">S</span><span class="p">):</span><span class="w"> </span><span class="nc">TaggedValue</span><span class="p">[</span><span class="nc">S</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="nc">TaggedValue</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="w"></span>

<span class="c1">// Below the changed code:</span>
<span class="c1">// - type `T =&gt; S` of argument `f` becomes `T =&gt; F[S]`</span>
<span class="c1">// - `(o, m)` is prepended as the first argument list</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TaggedValueAsyncShift</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">AsyncShift</span><span class="p">[</span><span class="nc">TaggedValue</span><span class="p">[</span><span class="nc">T</span><span class="p">]]:</span><span class="w"></span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">[</span><span class="nc">F</span><span class="p">[</span><span class="n">_</span><span class="p">],</span><span class="w"> </span><span class="nc">S</span><span class="p">](</span><span class="n">o</span><span class="p">:</span><span class="w"> </span><span class="nc">TaggedValue</span><span class="p">[</span><span class="nc">T</span><span class="p">],</span><span class="w"> </span><span class="n">m</span><span class="p">:</span><span class="w"> </span><span class="nc">CpsMonad</span><span class="p">[</span><span class="nc">F</span><span class="p">])(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">S</span><span class="p">]):</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">TaggedValue</span><span class="p">[</span><span class="nc">S</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span><span class="p">(</span><span class="n">value</span><span class="p">).</span><span class="n">map</span><span class="p">(</span><span class="nc">TaggedValue</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span><span class="n">_</span><span class="p">))</span><span class="w"></span>

<span class="k">object</span><span class="w"> </span><span class="nc">TaggedValue</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">transparent</span><span class="w"> </span><span class="k">inline</span><span class="w"> </span><span class="k">given</span><span class="w"> </span><span class="n">shiftedTaggedValue</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="nc">AsyncShift</span><span class="p">[</span><span class="nc">TaggedValue</span><span class="p">[</span><span class="nc">T</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="nc">TaggedValueAsyncShift</span><span class="p">[</span><span class="nc">T</span><span class="p">]()</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="object-oriented-interface">
<h3>Object-oriented interface.<a class="headerlink" href="#object-oriented-interface" title="Permalink to this heading">¶</a></h3>
<p>In some cases, we use classes – defined in an object-oriented manner – with private data.  If we want a class to provide an API for <a class="reference external" href="https://github.com/rssh/dotty-cps-async#dotty-cps-async"><strong>dotty-cps-async</strong></a>, then we can do this without breaking encapsulation. What is needed - to implement an async-shifted version of the function inside our class:</p>
<p>Example:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyIntController</span><span class="p">:</span><span class="w"></span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="kd">var</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">modify</span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Int</span><span class="p">):</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">sendSignal</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">old</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">modify_async</span><span class="p">[</span><span class="nc">F</span><span class="p">[</span><span class="n">_</span><span class="p">]](</span><span class="n">m</span><span class="p">:</span><span class="w"> </span><span class="nc">CpsMonad</span><span class="p">[</span><span class="nc">M</span><span class="p">])(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">Int</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">Int</span><span class="p">]):</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">Int</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">    </span><span class="kd">val</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))(</span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sendSignal</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
</pre></div>
</div>
<dl class="simple">
<dt>As we have seen, shifted functions have an additional type parameter: <code class="docutils literal notranslate"><span class="pre">F[_]</span></code> and a parameter <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/CpsMonad.scala#L20"><code class="docutils literal notranslate"><span class="pre">CpsMonad[F]</span></code></a> (or a more specific type, if needed).  Async transformer will substitute the call of <code class="docutils literal notranslate"><span class="pre">modify</span></code> into <code class="docutils literal notranslate"><span class="pre">modify_async</span></code> during compilation.</dt><dd><p>Sometimes, we already have <code class="docutils literal notranslate"><span class="pre">F[_]</span></code> as the type parameter of the enclosing class. In such a case, we can omit those additional parameters in the async variant.</p>
</dd>
<dt>Note that you should carefully decide whether you need async function support and how to deal with concurrent modifications.  For example, in the code snippet below, different changes will interleave with each other.</dt><dd><p>Usually, low-level constructs do not need async counterparts.</p>
</dd>
</dl>
</section>
<section id="special-semantics-for-substitutions-in-call-chains">
<span id="substitutions-in-call-chains"></span><h3>Special semantics for substitutions in call chains<a class="headerlink" href="#special-semantics-for-substitutions-in-call-chains" title="Permalink to this heading">¶</a></h3>
<p>Consider a chain of calls, which accepts async-shifted functions.  One example is <a class="reference external" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#withFilter(p:A=%3EBoolean):scala.collection.WithFilter[A,CC]"><code class="docutils literal notranslate"><span class="pre">withFilter</span></code></a> from the <a class="reference external" href="https://www.scala-lang.org/api/current/scala/collection/index.html"><strong>Scala collections library</strong></a>.  Let’s look at the following code:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">url</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">urls</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">await</span><span class="p">(</span><span class="n">status</span><span class="p">(</span><span class="n">url</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nc">Active</span><span class="w"></span>
<span class="w">  </span><span class="n">items</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">await</span><span class="p">(</span><span class="n">api</span><span class="p">.</span><span class="n">retrieveItems</span><span class="p">(</span><span class="n">url</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="n">item</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">items</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">item</span><span class="w"></span>
</pre></div>
</div>
<p>Here, the usual semantics of <a class="reference external" href="https://www.scala-lang.org/api/current/scala/collection/immutable/List.html#withFilter(p:A=%3EBoolean):scala.collection.WithFilter[A,CC]"><code class="docutils literal notranslate"><span class="pre">withFilter</span></code></a> assume that we iterate over <code class="docutils literal notranslate"><span class="pre">urls</span></code> only once.  But if we translate this expression according to the standard rules, we will receive two passes: one pass in async <code class="docutils literal notranslate"><span class="pre">withFilter</span></code> and the second pass in <code class="docutils literal notranslate"><span class="pre">flatMap</span></code>.</p>
<p>To perform the iteration once, we translate <code class="docutils literal notranslate"><span class="pre">withFilter</span></code> not to <code class="docutils literal notranslate"><span class="pre">F[WithFilter]</span></code> but to a substituted type <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/runtime/IterableAsyncShift.scala#L420"><code class="docutils literal notranslate"><span class="pre">DelayedWithFilter</span></code></a>, which holds the received predicate and delays actual evaluation upon the call of the next operation in the chain.</p>
<p>The implementation of class <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/runtime/IterableAsyncShift.scala#L420"><code class="docutils literal notranslate"><span class="pre">DelayedWithFilter</span></code></a> looks like:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">DelayedWithFilter</span><span class="p">[</span><span class="nc">F</span><span class="p">[</span><span class="n">_</span><span class="p">],</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="nc">C</span><span class="p">[</span><span class="nc">X</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">Iterable</span><span class="p">[</span><span class="nc">X</span><span class="p">],</span><span class="w"> </span><span class="nc">CA</span><span class="w"> </span><span class="o">&lt;:</span><span class="w"> </span><span class="nc">C</span><span class="p">[</span><span class="nc">A</span><span class="p">]](</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="p">:</span><span class="w"> </span><span class="nc">CA</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">:</span><span class="w"> </span><span class="nc">CpsMonad</span><span class="p">[</span><span class="nc">F</span><span class="p">],</span><span class="w"></span>
<span class="w">    </span><span class="n">p</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">Boolean</span><span class="p">],</span><span class="w"></span>
<span class="p">)</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nc">CallChainAsyncShiftSubst</span><span class="p">[</span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="nc">WithFilter</span><span class="p">[</span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="nc">C</span><span class="p">],</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">WithFilter</span><span class="p">[</span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="nc">C</span><span class="p">]]</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="c1">// return eager copy</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">_finishChain</span><span class="p">:</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">WithFilter</span><span class="p">[</span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="nc">C</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">withFilter</span><span class="p">(</span><span class="n">q</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">Boolean</span><span class="p">):</span><span class="w"> </span><span class="nc">DelayedWithFilter</span><span class="p">[</span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="nc">A</span><span class="p">,</span><span class="w"> </span><span class="nc">CX</span><span class="p">,</span><span class="w"> </span><span class="nc">CA</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">withFilter_async</span><span class="p">(</span><span class="n">q</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">Boolean</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">map</span><span class="p">[</span><span class="nc">B</span><span class="p">](</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">B</span><span class="p">):</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">C</span><span class="p">[</span><span class="nc">B</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">map_async</span><span class="p">[</span><span class="nc">B</span><span class="p">](</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">B</span><span class="p">]):</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">C</span><span class="p">[</span><span class="nc">B</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">flatMap</span><span class="p">[</span><span class="nc">B</span><span class="p">](</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">IterableOnce</span><span class="p">[</span><span class="nc">B</span><span class="p">]):</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">C</span><span class="p">[</span><span class="nc">B</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">flatMap_async</span><span class="p">[</span><span class="nc">B</span><span class="p">](</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">IterableOnce</span><span class="p">[</span><span class="nc">B</span><span class="p">]]):</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">C</span><span class="p">[</span><span class="nc">B</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">foreach</span><span class="p">[</span><span class="nc">U</span><span class="p">](</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">U</span><span class="p">):</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">Unit</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>
<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">foreach_async</span><span class="p">[</span><span class="nc">U</span><span class="p">](</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">U</span><span class="p">]):</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">Unit</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>I.e., in the delayed variant, all original methods should collect operations into the next delayed object or perform an actual batched call.
We also  have the method <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/runtime/IterableAsyncShift.scala#L427"><code class="docutils literal notranslate"><span class="pre">_finishChain</span></code></a>,  which is called when we have no next call in the chain; an example of such a case is <code class="docutils literal notranslate"><span class="pre">val</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">c.withFilter(p)</span></code>.</p>
<p>By convention, the substituted type should be derived from trait <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/runtime/CallChainAsyncShiftSubst.scala#L13"><code class="docutils literal notranslate"><span class="pre">CallChainAsyncShiftSubst[F,</span> <span class="pre">T,</span> <span class="pre">FT]</span></code></a>.</p>
<p>This structure has a nice categorical interpretation. If you are curious about that, read details in <a class="reference internal" href="random-notes/AsyncSubstCategoricalInterpretation.html#categorical-interpretation-for-callchainasyncsubst"><span class="std std-ref">Categorical interpretation for substitutions in async call chains:</span></a>.</p>
</section>
<section id="builder-methods">
<h3>Builder methods.<a class="headerlink" href="#builder-methods" title="Permalink to this heading">¶</a></h3>
<p>Yet one common usage pattern of high-order functions is builder methods, where we use high-order functions to build some processing algorithm.</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="nc">ReadChannel</span><span class="p">[</span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="nc">A</span><span class="p">]:</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">map</span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">B</span><span class="p">):</span><span class="w"> </span><span class="nc">ReadChannel</span><span class="p">[</span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="nc">B</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Here, method <code class="docutils literal notranslate"><span class="pre">map</span></code> is used for building the streaming interface. We can provide an async variant of <code class="docutils literal notranslate"><span class="pre">map</span></code> which will return the same type as the original function:</p>
<div class="highlight-scala notranslate"><div class="highlight"><pre><span></span><span class="k">trait</span><span class="w"> </span><span class="nc">ReadChannel</span><span class="p">[</span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="nc">A</span><span class="p">]:</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">map</span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">B</span><span class="p">):</span><span class="w"> </span><span class="nc">ReadChannel</span><span class="p">[</span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="nc">B</span><span class="p">]</span><span class="w"></span>

<span class="w">  </span><span class="k">def</span><span class="w"> </span><span class="nf">mapAsync</span><span class="p">(</span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nc">F</span><span class="p">[</span><span class="nc">B</span><span class="p">]):</span><span class="w"> </span><span class="nc">ReadChannel</span><span class="p">[</span><span class="nc">F</span><span class="p">,</span><span class="w"> </span><span class="nc">B</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
<p>Also, we can see that our channel structure is already build on top of <code class="docutils literal notranslate"><span class="pre">F[_]</span></code>, so it is not necessary to pass <code class="docutils literal notranslate"><span class="pre">F</span></code> to method parameter.</p>
<p>For convenience, <a class="reference external" href="https://github.com/rssh/dotty-cps-async#dotty-cps-async"><strong>dotty-cps-async</strong></a> supports both naming variants of <code class="docutils literal notranslate"><span class="pre">mapAsync</span></code>: camelCase <code class="docutils literal notranslate"><span class="pre">mapAsync</span></code> and snake_case <code class="docutils literal notranslate"><span class="pre">map_async</span></code>.</p>
<p>We propose to use the following convention when naming such methods:</p>
<ul class="simple">
<li><p>use <code class="docutils literal notranslate"><span class="pre">method_async</span></code> when the async method will unlikely be called directly by the programmer and will be used only for substitution in high-order function;</p></li>
<li><p>use <code class="docutils literal notranslate"><span class="pre">methodAsync</span></code> when we expect that the developer can use this method directly along with cps substitution.</p></li>
</ul>
</section>
<section id="async-high-order-functional-interfaces">
<h3>Async high-order functional interfaces<a class="headerlink" href="#async-high-order-functional-interfaces" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>For a case with an asynchronous high-order function interface (i.e. methods which accept functions like <code class="docutils literal notranslate"><span class="pre">f:(A</span> <span class="pre">=&gt;</span> <span class="pre">F[B])</span></code>), the <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/Async.scala#L30"><code class="docutils literal notranslate"><span class="pre">async</span></code></a> macro can automatically transform the asynchronous result to have the same signature,</dt><dd><p>so you can use <a class="reference external" href="https://github.com/rssh/dotty-cps-async/blob/master/shared/src/main/scala/cps/Async.scala#L19"><code class="docutils literal notranslate"><span class="pre">await</span></code></a> calls inside async lambdas without implementing additional methods or type classes.</p>
</dd>
</dl>
</section>
<section id="automatic-generation-of-shifted-functions">
<h3>Automatic generation of shifted functions<a class="headerlink" href="#automatic-generation-of-shifted-functions" title="Permalink to this heading">¶</a></h3>
<dl class="simple">
<dt>When <cite>dotty-cps-async-compiler-plugin</cite> is enabled, it is possible to generate shifted functions automatically in simple cases: where the higt-order function</dt><dd><p>calls argument (but not store it in a variable or in an object field).  In such cases, you can annotate your high-order method with
<cite>cps.plugin.makeCps</cite> annotation and the plugin will generate a shifted function with the same name as the original function but with the</p>
</dd>
</dl>
<p>shifted arguments and suffix <code class="docutils literal notranslate"><span class="pre">_async</span></code>.</p>
<p>Example:
.. code-block:: scala</p>
<blockquote>
<div><p>import cps.plugin.annotation.makeCps</p>
<p>case class Summary(min:Double, max:Double, sum:Double, n:Int)</p>
<p>object MeasurementsOps {</p>
<blockquote>
<div><p>&#64;makeCps
def gatherStatistics[A](data: Seq[A])(f: A=&gt;Double): Summary = {</p>
<blockquote>
<div><dl class="simple">
<dt>data.foldLeft(Summary(Double.MAX,Doube.MIN,0,0)) { (s,e) =&gt;</dt><dd><p>val c = f(e)
s.copy(min=Math.min(s.min,c),max=Math.max(s.max,c), sum=c.sum+c, n=s.n+1)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>With this definition we can use gatherStatistics with async context even on platforms,  which do not support continuations.
This stared as a work of Olena Kravchenko in Google Summer of Code 2023 project.</p>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">High-order functions.</a><ul>
<li><a class="reference internal" href="#async-shift-substitution">Async shift substitution.</a></li>
<li><a class="reference internal" href="#loom-based-runtime-await">Loom-based runtime await.</a></li>
<li><a class="reference internal" href="#how-to-provide-shifted-functions">How to provide shifted functions.</a><ul>
<li><a class="reference internal" href="#functional-interface">Functional interface.</a></li>
<li><a class="reference internal" href="#object-oriented-interface">Object-oriented interface.</a></li>
<li><a class="reference internal" href="#special-semantics-for-substitutions-in-call-chains">Special semantics for substitutions in call chains</a></li>
<li><a class="reference internal" href="#builder-methods">Builder methods.</a></li>
<li><a class="reference internal" href="#async-high-order-functional-interfaces">Async high-order functional interfaces</a></li>
<li><a class="reference internal" href="#automatic-generation-of-shifted-functions">Automatic generation of shifted functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="BasicUsage.html"
                          title="previous chapter">Dependency</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="ReturningClause.html"
                          title="next chapter">Non-local returns</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/HighOrderFunctions.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ReturningClause.html" title="Non-local returns"
             >next</a> |</li>
        <li class="right" >
          <a href="BasicUsage.html" title="Dependency"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">dotty-cps-async 1.0.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">High-order functions.</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020-2025, Ruslan Shevchenko.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.2.3.
    </div>
  </body>
</html>